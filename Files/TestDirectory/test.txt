线程是创建并发的底层工具，因此它有一定的局限性。特别是：虽然在线程启动时不难向其中传递数据，但是当线程Join后却难以从中得到“返回值”。通常不得不创建一些共享字段（来得到“返回值”）。此外，捕获和处理线程中操作抛出的异常也是非常麻烦的。在线程完成后，就无法再次启动它，相反只能够将其Join（并阻塞当前操作线程）。这些局限性会影响细粒度并发性的实现。换言之，这种方式难以将小的并发组合成大的并发操作（这对于异步编程而言非常重要，后面的章节将对此进行介绍），并会增加手动同步处理（例如使用锁、信号发送等）的依赖，而且很容易造成问题。直接使用线程也会对性能产生影响，具体可参见14.2.13节。而且如果需要运行大量并发的I/O密集型操作，那么基于线程的方法仅仅在线程本身的开销方面就会消耗成百上千兆的内存。